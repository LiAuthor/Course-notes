[TOC]

# 第一章

## 操作系统的基本概念

操作系统（OS），控制和管理整个计算机硬件和软件资源，并合理地组织、分配、调度。提供给用户和其他软件接口与环境，是计算机系统最基本的软件。

+ 系统资源管理者
  + 处理机管理
  + 存储器管理
  + 文件管理
  + 设备管理
+ 最接近硬件的一层软件
+ 向上层提供方便易用的服务
  + 封装思想
  + GUI：图形化用户接口
  + 联机命令接口：例Windows Power shell，说一做一交互式
  + 脱机命令接口：说一堆做一堆批处理式
  + 程序接口：即系统调用，用户通过程序间接使用

联机与脱机是用户不通过应用程序，直接控制操作系统，GUI与程序接口是用户通过应用程序间接控制操作系统。

<img src=".\操作系统\OS层次结构.png" alt="OS层次结构" style="zoom: 80%;" />

## 操作系统的四个特征

+ 并发
+ 共享
+ 虚拟
+ 异步

### 并发

两个或多个事件在同一**时间段**内发生。宏观上同时发生，微观上交替发生。

区别并行：两个或多个事件在同一**时刻**发生。受物理介质影响。

单核CPU同一时刻只能执行一个程序，各个程序只能并发地执行，

多核CPU同一时刻可以同时执行多个程序，多个程序可以并行地执行。

[https://www.cnblogs.com/dtyy/p/13946790.html](https://www.cnblogs.com/dtyy/p/13946790.html)

<img src=".\操作系统\1.png" alt="1" style="zoom:67%;" />

### 共享

指系统中的资源可供内存中**多个并发**执行的进程共同使用。

若失去并发性，则系统仅一个程序正在运行，共享性便失去意义，

若失去共享性，QQ与Wechat则不能同时访问硬盘资源，无法同时发送文件，即无法并发。

综上可知，并发性与共享性**互为存在条件**。

+ 互斥共享方式：系统某些资源在一个时间段内只允许一个进程访问。

例如：QQ与WeChat不能同时调用摄像头。

+ 同时共享方式：系统某些资源在一个时间段内允许多个进程**同时**访问。

  同时是宏观上的，微观上仍然是分时共享。

例如：QQ在发送A文件，WeChat在发送B文件，宏观上，二者在同时发送文件，微观上，两个进程是交替访问硬盘的。

### 虚拟

指把一个物理实体变为若干个逻辑上的对应物。

+ 空分复用技术（虚拟存储技术）

示例：当前电脑内存4G，正在运行GTA5：4G，QQ：256MB，WeChat：256MB，正在运行程序总内存大于电脑实际物理内存。

+ 时分复用技术：微观上处理机在各个微小的时间段内交替着为各个进程服务

示例：当前电脑单核CPU，正在运行GTA5，QQ，WeChat等多个软件。

### 异步

指多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行并不是一贯到底的，二十走走停停，以不可预知的速度向前推进，这就是进程的异步性。

## 操作系统的发展与分类

+ 手工操作阶段
+ 批处理阶段
  + 单道批处理系统
  + 多道批处理系统（操作系统开始出现）

+ 分时操作系统
+ 实时操作系统
+ 网络操作系统
+ 分布式操作系统
+ 个人计算机操作系统

### 单道批处理系统

缺点：内存中仅能有一道程序运行，只有该程序运行结束之后才能调入下一道程序。

CPU有大量的时间是在 空闲等待I/O完成。资源利用率依然很低。

<img src=".\操作系统\image-20220501214608486.png" alt="image-20220501214608486" style="zoom: 67%;" />

### 多道批处理系统

主要优点：多道程序并发执行，共享计算机资源。资源利用率大幅提升，CPU和其他资源更能保持“忙碌”状态，系统吞吐量增大。 

主要缺点：用户响应时间长，没有人机交互功能（用户提交自己的作业之后就只能等待计算机处理完成，中间不能控制自己的作业执行。

<img src=".\操作系统\image-20220501214915091.png" alt="image-20220501214915091" style="zoom:80%;" />

### 分时操作系统

计算机一时间片为单位轮流为各个用户/作业服务，各个用户可通过终端与计算机进行交互。

优点：用户请求响应及时，解决人机交互问题。

缺点：各请求等级相同，不能优先处理一些紧急事务。

### 实时操作系统

优点：能够优先响应一些紧急任务，某些紧急任务不需时间片排队。 

在实时操作系统的控制下，计算机系统接收到外部信号后及时进行处理，并且要在严格的时限内处理完事 件。实时操作系统的主要特点是及时性和可靠性。

+ 硬实时系统：必须在绝对严格规定的时间内完成处理，如自动驾驶，导弹系统
+ 软实时系统：能接受偶尔违反时间规定，如12306火车订票系统

### 其他操作系统

网络操作系统：是伴随着计算机网络的发展而诞生的，能把网络中各个计算机有机地结合起来，实现数据传送等功能，实现网络中各种资源的共享（如文件共享）和各台计算机之间的通信。

分布式操作系统：主要特点	是分布性和并行性。系统中的各台计算机地位相同，任何工作都可以分布在这些计算机上，由它们并行、协同完成这个任务。

个人计算机操作系统：如 Windows XP、MacOS，方便个人使用。

## 操作系统的运行机制

+ 两种指令
  + 特权指令
  + 非特权指令
+ 两种处理机状态
  + 核心态
  + 用户态
+ 两种程序
  + 内核程序
  + 应用程序

### 特权指令与非特权指令

只能由操作系统内核部分使用，不允许用户直接使用的命令，如I/O指令，设置中断屏蔽指令、清内存指令、存储保护指令和设置时钟指令。

应用程序只能使用非特权指令，如：加法指令，减法指令等。

### 核心态

又称管态，系统态，是操作系统管理程序执行时机器所处的状态。具有较高特权，能执行包括特权指令的一切指令，能访问所有寄存器和存储器。

### 用户态

又称目态，是用户程序执行时机器所处的状态，是具有较低特权的执行状态，它只能执行规定的指令，只能访问指定的寄存器和存储器。

CPU 中有一个寄存器叫程序状态字寄存器（PSW），其中有个二进制位，1表示内核态，0表示用户态。

### 核心态与用户态的切换

内核态->用户态：执行一条特权指令—修改PSW的标志位为“用户态”，这个动作意味着操作系统 将主动让出CPU使用权。

用户态->内核态：由“中断”引发，硬件自动完成变态过程，触发中断信号意味着操作系统将强行夺回CPU的使用权。

引发中断信号的共性：需要CPU介入。

## 中断和异常

+ 中断的作用
+ 中断的类型
  + 内中断（异常）
  + 外中断
+ 中断机制的基本原理

### 中断的作用

中断会使CPU由用户态变为核心态，操作系统夺回CPU控制权。

中断是让操作系统内核夺回CPU控制权的唯一途径。

若没有中断，应用程序一直执行，并发性失去意义。

### 内中断

与当前执行的指令有关，中断信号来自CPU内部。

例子：

1. 流氓软件在用户态下尝试执行特权指令，会引发中断信号；

2. 执行除法指令时，发现除数为0，会引发中断信号；
3. 当应用程序想请求操作系统内核的服务，会执行**陷入指令**，引发中断信号。

陷入指令：应用程序主动将CPU控制权还给操作系统内核。系统调用就是通过陷入指令完成的。

陷入指令 ，又称trap 指令 ，访管指令。

### 外中断

与当前执行的指令无关，中断信号来源于CPU外部。

例子：

1. 时钟中断：由时钟部件发来的中断信号；
2. I/O中断：由输入/输出设备发来的中断信号。

### 中断机制基本原理

不同的中断信号，需要用不同的中断处理程序来处理。

当CPU检测到中断信号后，会根据中断信号的类型去查询“中断向量表”，以此来找到相应的中断处理程序在内存中的存放位置。

<img src=".\操作系统\image-20220502104030192.png" alt="image-20220502104030192" style="zoom: 50%;" />

## 系统调用

+ 定义
+ 系统调用与库函数的区别
+ 系统调用为什么是必须的
+ 什么功能要用系统调用实现
+ 系统调用的过程

### 定义

系统调用是操作系统提供给应用程序（程序员/编程人员）使用的**接口**，可以理解为一种可供应用程序调用的特殊函数，应用程序可以通过系统调用来请求获得操作系统内核的服务。

### 与库函数的区别

将系统调用封装成库函数，以隐藏系统调用的一些细节，使程序员编程更加方便。

<img src=".\操作系统\image-20220502105039907.png" alt="image-20220502105039907" style="zoom:50%;" />

### 为什么必须

场景：当WPS与Word同时打印文件，不能并发交替运行。

解决方法：由操作系统内核对共享资源进行统一的管理，并向上提供 “系统调用” ，用户进程想要使用打印机这种共享资源，只能通过系统调用向操作系统内核发出请求。内核会对各个请求进行协调处理。

### 什么功能要用系统调用

凡是与共享资源有关的操作（如存储分配、I/O操作、文件管理等），都必须通过系统调用的方式向操作系统内核提出服务请求，由操作系统内核代为完成。这样可以保证系统的稳定性和安全性，防止用户进行非法操作。

<img src=".\操作系统\image-20220502105633655.png" alt="image-20220502105633655" style="zoom: 67%;" />

### 系统调用的过程

------

传递系统调用参数->执行陷入指令（用户态）-> 执行相应的内请求和程序处理系统调用（核心态） ->返回应用程序 

注意：

1. 陷入指令是在用户态执行的，执行陷入指令之后立即引发一个内中断，使CPU进入核心态 ;
2. 发出系统调用请求是在用户态，而对系统调用的相应处理在核心态下进行。

------

## 操作系统的体系结构

+ 大内核/单内核/宏内核
+ 微内核

### 内核

+ 时钟管理
+ 中断管理
+ 原语
  + 是一种特殊的程序
  + 处于操作系统最底层，最接近硬件的部分
  + 运行具有原子性：一气呵成，不可中断
  + 运行时间短，调用频繁
+ 对系统资源进行管理的功能
  + 进程管理
  + 存储器管理
  + 设备管理

### 大内核与微内核

<img src=".\操作系统\image-20220502111407261.png" alt="image-20220502111407261" style="zoom:67%;" />

注意：操作系统内核需要运行在内核态，操作系统的非内核功能运行在用户态。

<img src=".\操作系统\image-20220502111456548.png" alt="image-20220502111456548" style="zoom:67%;" />

注意：变态的过程是有成本的，要消耗不少时间，频繁地变态会降低系统性能。

# 第二章

## 进程的概念、组成、特征

### 概念

资源分配的基本单位 ，独立运行的基本单位。

程序：是静态的，就是个存放在磁盘里的可执行文件。

进程：是动态的，是程序的一次执行过程。

### 组成

+ PCB（Process Control Block）进程控制块
  + 进程描述信息
  + 进程控制和管理信息
  + 资源分配清单
  + 处理机相关信息
+ 程序段
  + 程序的代码（指令序列）
+ 数据段
  + 运行过程中产生的各种数据（如：程序中定义的变量）

PCB是给操作系统用的，程序段与数据段是进程自己用的。

示例：同时挂3个QQ号，会对应3个QQ进程，它们的PCB与数据段各不相同，但程序段的内容都是相同的。

程序段，数据段，PCB三部分组成了进程实体，即进程映像。

进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。

### 特征

+ 动态性：程序的一次执行过程，动态的产生、变化、消亡。
+ 并发性：内存中存在多个进程实体，各进程可并发执行。
+ 独立性：进程是独立运行，独立获得资源，独立接受调度的基本单位。
+ 异步性：各进程独立运行，以不可预知的速度向前推进。OS要提供“进程同步机制”来解决异步问题。
+ 结构性：PCB，程序段，数据段。

## 进程的状态与转换

+ 进程的状态
  + **运行状态**
  + **就绪状态**
  + **阻塞状态**
  + 创建状态
  + 终止转态
+ 进程的转换
  + 就绪态-->运行态
  + 运行态-->就绪态
  + 运行态-->阻塞态
  + 阻塞态-->就绪态

<img src=".\操作系统\image-20220525162015525.png" alt="image-20220525162015525" style="zoom:67%;" />

创建态：进程被创建时，OS为其分配资源、初始化PCB。

就绪态：进程被创建后，已具备运行条件，但是没有空闲CPU，暂时不能执行。

运行态：进程正在CPU上运行。

阻塞态：在运行态，进程可能会请求等待某个事件的发生，如等待某种资源的分配(如打印机)，或者等待其他进的响应，在这个事件发生之前，此进程无法向前推进，OS会让此进程进入阻塞态。

终止态：一个进程可以执行exit系统调用，请求OS终止该进程。此时此进程进入终止态，OS收回其内存空间资源与进程的PCB，终止工作完成后，此进程彻底消失。

进程PCB中，会有一个变量state来表示进程的当前状态。

+ 进程的组织

  + 链接方式

  <img src=".\操作系统\屏幕截图 2022-05-25 154347.jpg" alt="屏幕截图 2022-05-25 154347" style="zoom: 67%;" />

  + 索引方式

  <img src=".\操作系统\屏幕截图 2022-05-25 154409.jpg" alt="屏幕截图 2022-05-25 154409" style="zoom: 67%;" />

## 进程控制

> 利用原语，实现进程状态转换。

原语的执行具有原子性，执行过程只能一气呵成，期间不允许被中断。

可利用关中断指令和开中断指令这两个特权指令实现原子性。

正常情况：CPU每执行完一条指令都会例 行检查是否有中断信号需要处理，如果有，则暂停运行当前这段程序，转而执行相应的中断处理程序。

<img src=".\操作系统\image-20220525164725973.png" alt="image-20220525164725973" style="zoom:67%;" />

### 进程的创建

+ 创建原语
  + 申请空白PCB
  + 为新进程分配所需资源
  + 初始化PCB
  + 将PCB插入就绪队列
+ 引起进程创建的事件
  + 用户登录
  + 作业调度
  + 提供服务
  + 应用请求

### 进程的终止

+ 撤销原语
  + 从PCB集合中找到终止进程的PCB
  + 若进程正在运行，立即剥夺CPU，将CPU分配给其他进程
  + 终止其所有子进程(进程间的关系是树形结构)
  + 将该进程拥有的所有资源归还给父进程或OS
  + 删除PCB
+ 引起进程终止的事件
  + 正常结束：进程自己请求终止，exit系统调用
  + 异常结束：整数除以0，非法使用特权指令
  + 外界干预：kill命令

### 进程的阻塞和唤醒

+ 阻塞
  + 阻塞原语
    + 找到要阻塞的进程对应的PCB
    + 保护进程运行现场，将PCB状态信息设置为阻塞态，暂时停止进程运行
    + 将PCB插入相应事件的等待队列
  + 引起阻塞的事件
    + 需要等待系统分配的某种资源
    + 需要等待相互合作的其他进程完成工作
+ 唤醒
  + 唤醒原语
    + 在事件等待队列中找到PCB
    + 将PCB从等待队列中移除，设置进程为就绪态
    + 将PCB插入就绪队列，等待被调度
  + 引起唤醒的事件
    + 等待的事件发生：接铃人还需系铃人

### 进程的切换



### 调度的层次

+ 三个层次
  + 高级调度：**作业**调度，面向作业，外存调入内存，频率**最低**
  + 中级调度：**内存**调度，面向进程，外存调入内存，频率**中等**
  + 低级调度：**进程**调度/处理机调度，最基本的一种调度，频率**最高**，一般几十毫秒一次

<img src=".\操作系统\image-20220527184334619.png" alt="image-20220527184334619" style="zoom: 50%;" />

### 调度的时机



### 调度的切换与过程

+ 低级调度
  + 需要调度与切换
    + 当前进程**主动放弃**
    + 当前进程**被动放弃**
  + 不能进行调度与切换
    + 处理中断的过程中
    + 进程在操作系统内核程序临界区中
    + 原子操作过程中

#### 狭义的进程调度与进程切换的区别

**狭义的进程调度**指的是从就绪队列中选中一个要运行的进程。这个进程可以是刚刚被暂停执行的进程，也可能是另一个进程，后一种情况就需要进程切换。

**进程切换**是指一个进程让出处理机，由另一个进程占用处理机的过程。

进程切换的过程主要完成了： 

1. 对原来运行进程各种数据的保存 
2. 对新的进程各种数据的恢复 （如：程序计数器、程序状态字、各种数据寄存器等处理机现场信息，这些信息一般保存在进程控制块）

### 调度的方式

+ 非抢占式：非剥夺调度方式。只允许进程主动放弃处理机。在运行过程中即便有更紧迫的任务到达，当前进程依然会继续使用处理机，直到该进程终止或主动要求进入阻塞态。
+ 抢占式：剥夺调度方式。当一个进程正在处理机上执行时，如果有一个更重要或更紧迫的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给更重要紧迫的那个进程。

## 调度算法的评价指标

+ CPU利用率：CPU忙碌的时间/总时间

+ 系统吞吐量：单位时间内完成作业的数量。总共完成作业数量/总共消耗时间

+ 周转时间

  + 周转时间、平均周转时间

    周转时间：作业完成时间-作业提交时间

    平均周转时间：各作业周转时间之和/作业数量

  + 带权周转时间，平均带权周转时间

    带权周转时间：周转时间/作业实际运行时间

    平均带权周转时间：各作业带权周转时间/作业数量

+ 等待时间：进程或者作业处于等待处理机状态时间之和。

+ 响应时间：用户提交请求到首次产生响应所用的时间。

## 调度算法

+ 先来先服务(FCFS)
+ 短作业优先(SJF)
+ 高响应比优先(HRRN)

各种调度算法的学习思路 :

1. 算法思想
2. 算法规则
3. 这种调度算法是用于**作业调度**还是**进程调度**
4. **抢占式**还是**非抢占式**
5. 优缺点
6. 是否会导致**饥饿**：某进程或者作业长期得不到服务

### 先来先服务（FCFS，First Come First Serve）

+ 按照作业/进程到达的先后顺序
+ 非抢占式
+ 对长作业有利，对短作业不利
+ 利于CPU繁忙型作业，不利于I/O繁忙型作业

### 短作业优先（SJF，Shortest Job First）

+ 非抢占式：每次调度时选择当前已到达且运行时间最短的作业/进程。
+ 抢占式（最短剩余时间优先算法）：每当有进程加入就绪队列改变时就需要调度，如果新到达的进程剩余时间比当前运行的进程剩余时间更短，则由新进程抢占处理机，当前运行进程重新回到就绪队列。另外，当一个进程完成时也需要调度。
+ 对长作业不利，对短作业有利。
+ 有饥饿现象。

### 高响应比优先（HRNN）

$$
响应比=\frac{等待时间+要求服务时间}{要求服务时间}
$$

+ 作业的等待时间相同时，要求服务时间越短，响应比越高，有利于短作业。
+ 要求服务时间相同时，等待时间越长，响应比越高，先来先服务。
+ 无饥饿现象。

### 时间片轮转（RR，Round-Robin）

> 轮流让就绪队列中的进程依次执行一个时间片。

+ 时间片大小可人为设定。
+ 在运行完一个时间片时，未运行完毕的进程与新到达的进程相比，新到达的进程优先进入就绪队列。
+ 若处理机上目前的进程剩余时间小于时间片，则当前进程运行完后，主动放弃处理机，发生调度。
+ 抢占式

### 优先级

+ 动态优先级：进程运行过程中，动态调整优先级。依据：占有CPU长短、就绪进程等待CPU时间的长短。
+ 静态优先级：创建进程时确定，整个运行周期保持不变。

+ 非抢占式：当一个进程正在处理机上运行时，即使有某个优先级更高的进程进入就绪队列，仍然让正在进行的进程继续运行，直到当前进程主动放弃处理机时，在将处理机分配给优先级更高的进程。

+ 抢占式：当一个进程正在处理机上运行时，有某个优先级更高的进程进入就绪队列，则立即停止正在运行的进程，将处理机分配给优先级更高的进程。

一般情况：

1. 系统进程高于用户进程
2. 交互式进程高于非交互式
3. I/O进程高于计算型进程

### 多级反馈队列

+ 时间片轮转与优先级调度算法的综合与发展。
+ 动态调整优先级与时间片。队列序号越高，优先级越低，时间片越大。
+ 提高系统吞吐量，缩短平均周转时间照顾短进程。

+ 实现思想：

1. 设置多个就绪队列，队列序号越高，优先级越低，时间片越大（如：1,2,4,8...）；
2. 新进程进入，从第1级队列开始，按照FCFS原则等待调度。若它在时间片内运行完，则撤离系统，若它在第一个时间片内没有完成，则进入2级队列末尾，按照FCFS，若它在第2级队列的一个时间片内仍没有完成，则进入第三级队列末尾，以此类推；
3. 仅当第1级队列为空时，调度程序才调度第2级队列中的进程运行；即在调度第i级队列中的进程之前，第1至i-1级队列中的进程必须已经为空。

+ 优点：短作业优先，周转时间较短。

### 进程同步

指协调完成某个共同任务的并发线程，在某些位置上**指定线程的先后执行次序、传递信号或消息**。

比如：有 A、B 两个进程分别负责读和写数据的操作，这两个线程是相互合作、相互依赖的。那么写数据应该发生在读数据之前。而实际上，由于**异步性**的存在，可能会发生先读后写的情况，而此时由于缓冲区还没有被写入数据，读进程 A 没有数据可读，因此读进程 A 被阻塞。

### 进程互斥

**临界资源**：一个时间段内只允许一个进程使用的资源。

对临界资源的访问，必须互斥地进行。

为了实现对临界资源的互斥访问，同时保证系统整体性能，需要遵循以下原则： 

1. 空闲让进：临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区； 
2. 忙则等待：当已有进程进入临界区时，其他试图进入临界区的进程必须等待；
3. 有限等待：对请求访问的进程，应保证能在有限时间内进入临界区（保证不会饥饿）；
4. 让权等待：当进程不能进入临界区时，应立即释放处理机，防止进程忙等待。

由于进程**并发性**的存在，并发执行的线程不可避免地需要共享一些系统资源，比如内存、打印机、摄像头等。

比如：A同学在用WPS打印论文，B同学在用Word打印论文，对打印机的访问不能同时进行。

<img src=".\操作系统\进程互斥.png" alt="进程互斥" style="zoom:67%;" />

[https://cloud.tencent.com/developer/article/1803377](https://cloud.tencent.com/developer/article/1803377)

### 进程互斥硬件实现方法

+ 中断屏蔽方法

  + 利用开/关中断指令实现

+ TestAndSet（TS指令/TSL指令）

  <img src=".\操作系统\TSL指令.jpg" alt="TSL指令" style="zoom: 67%;" />

+ Swap指令（XCHG指令）

  <img src=".\操作系统\Swap指令.jpg" alt="Swap指令" style="zoom:67%;" />

### 进程互斥软件实现方法

#### 单标志法

设置公用整型变量`turn`，用于指示允许进入临界区的进程编号。

| P0进程             | P1进程             |        |
| ------------------ | ------------------ | ------ |
| while(turn != 0);  | while(turn != 1);  | 进入区 |
| critical section;  | critical section;  | 临界区 |
| turn = 1;          | turn = 0;          | 退出区 |
| remainder section; | remainder section; | 剩余区 |

违背**空闲让进**。

#### 双标志先检查

进程访问临界资源之前，先检查临界资源是否正在被访问。

设置`flag[i]`，如果第`i`个元素值为`FALSE`，表示`Pi`进程未进入临界区。

| Pi进程                 | Pj进程                 |        |
| ---------------------- | ---------------------- | ------ |
| while(flag[j]);    //1 | while(flag[i]);    //2 | 进入区 |
| flag[i] = TRUE;    //3 | flag[j] = TRUE;    //4 | 进入区 |
| critical section;      | critical section;      | 临界区 |
| flag[i] = FALSE;       | flag[j] = FALSE;       | 退出区 |
| remainder section;     | remainder section;     | 剩余区 |

优点：不会交替进入，可连续使用。

缺点：若按照1-2-3-4的顺序执行，会同时进入临界区。违背**忙则等待**。

#### 双标志后检查

双标志先检查基础上，本算法先将自己的标志设置为`TRUE`，再检测对方的状态，若对方标志为TRUE，则进程等待，否则进入临界区。

| Pi进程             | Pj进程             |        |
| ------------------ | ------------------ | ------ |
| flag[i] = TRUE;    | flag[j] = TRUE;    | 进入区 |
| while(flag[j]);    | while(flag[i]);    | 进入区 |
| critical section;  | critical section;  | 临界区 |
| flag[i] = FALSE;   | flag[j] = FALSE;   | 退出区 |
| remainder section; | remainder section; | 剩余区 |

导致**饥饿现象**。

#### Peterson算法

孔儒让梨 。

| Pi进程                              | Pj进程                              |        |
| ----------------------------------- | ----------------------------------- | ------ |
| flag[i] = TRUE; turn = j;    //1    | flag[j] = TRUE; turn = i;    //2    | 进入区 |
| while(flag[j] && turn == j);    //3 | while(flag[i] && turn == i);    //4 | 进入区 |
| critical section;                   | critical section;                   | 临界区 |
| flag[i] = FALSE;                    | flag[j] = FALSE;                    | 退出区 |
| remainder section;                  | remainder section;                  | 剩余区 |

违背**让权等待**。

## 信号量

信号量机制是一种较强的机制，用来解决同步与互斥问题，被原语`wait(s)`和`signal(s)`访问，记为`P`操作与`V`操作。

### 整型信号量

定义一个用于表示资源数目的整型量`S`，`wait`和`signal`操作可描述为：

```c
wait(S){
	while(S<=0);
	S=S-1;
}
signal(S){
	S=S+1;
}
```

若`S<=0`，则不断循环，违背**让权等待**，使进程处于忙等状态。

### 记录型信号量

不存在忙等现象。`value`表示资源数目的整型变量，`L`表示进程链表，链接所有等待该资源的进程。

```c
typedef struct{
    int value;
    struct process *L;
} semaphore;

void wait(semaphore S){
    S.value --;
    if(S.value<0){
        add this process to S.L;
        block(S.L);//自我阻塞，放弃处理机，加入该资源的等待队列，遵循让权等待
    }
}

void signal(semaphore S){
    S.value ++;
    if(S.value<=0){
        remove a process P from S.L;
        wakeup(P);//队列中仍有等待该资源的进程被阻塞，将该等待进程唤醒
    }
}
```

### 利用信号量实现同步

`P2`进程`y`语句要使用`P1`进程`x`语句的运行结果。

```c
semaphare S=0;
P1(){
    x;
    V(S);//告诉P2，语句x已经完成
    ...
}
P2(){
    ...
    P(S);//检查x语句是否完成
    y;
    ...
}
```

### 利用信号量实现进程互斥

```c
semaphore S=1;
P1(){
    ...
    P(S);
    进程P1的临界区；
    V(S);
    ...
}
P2(){
    ...
    P(S);
    进程P2的临界区；
    V(S);
    ...
}
```

### 利用信号量实现前驱关系

进程前驱图

<img src=".\操作系统\image-20220531154007526.png" alt="image-20220531154007526" style="zoom:50%;" />

```c
/*
信号量
1->2:a1
1->3:a2
2->4:b1
2->5:b2
3->6:c
4->6:d
5->6:e
*/
S1(){
    ...;
    V(a1);V(a2);
}
S2(){
    P(a1);
    ...;
    V(b1);V(b2);
}
S3(){
    P(a2);
    ...;
    V(c);
}
S4(){
    P(b1);
    ...;
    V(d);
}
S5(){
    P(b2);
    ...;
    V(e);
}
S6(){
    P(c);P(d);P(e);
    ...;
}
```

### 经典同步问题

#### 生产者-消费者问题

一个盘子，爸爸放苹果，女儿吃苹果，妈妈放橘子，儿子吃橘子。

共4个进程，爸爸妈妈互斥，爸爸女儿同步，妈妈儿子同步。

```c
//信号量
semaphore plate=1,apple=0,orange=0;

dad(){
    
}
mom(){
    
}
daughter(){
    
}
son(){
    
}
```



#### 读者-写者问题

`count`计数器，记录当前读者的数量，初值为0。互斥信号量：`mutex`，互斥信号量`rw`，保证读者和写者的互斥访问。

+ 读进程优先

```

```



+ 写进程优先

```

```



#### 哲学家进餐问题

**问题描述：**一张圆桌坐着5名哲学家，每两名哲学家之间的桌子上摆着一根筷子，两根筷子中间是一碗米饭。哲学家饥饿时，就拿起左右两根筷子（一根一根地拿起）。若筷子已经在他人手上，则需要等待。只有拿到两根筷子时，才可以进餐，进餐完毕后，放下筷子继续思考。

```

```



#### 吸烟者问题

**问题描述：**三个吸烟者进程和一个供应者进程，每个抽烟者不停的卷烟并抽掉它，但是要卷烟并抽掉一支烟，
抽烟者需要三种材料：烟草、卷纸、胶水 。三个抽烟者中第一个拥有烟草，第二个拥有卷纸，第三个拥有胶水。
供应者进程不停的供应三种材料，供应者每次将两种材料放在桌子上，拥有剩下的那种材料的抽烟者卷一根抽掉它
并通知供应者进程一个信号完成了。供应者进程就会将两种材料放在桌上，这个过程一直重复（三个抽烟者轮流吸烟）

组合1：卷纸+胶水
组合2：烟草+胶水
组合3：烟草+卷纸

```c

```



### 管程

+ 解决信号量机制编程麻烦、易出错的问题
+ 组成
  + 共享数据结构
  + 对数据结构初始化的语句
  + 一组用来访问数据结构的过程（函数）
+ 特征
  + 各外部进程/线程只能通过管程提供的特定“入口”才能访问共享数据
  + 每次只允许一个进程在管道内执行某个内部流程

[https://www.cnblogs.com/binarylei/p/12544002.html](https://www.cnblogs.com/binarylei/p/12544002.html)

[什么是管程，管程机制及其使用方法详解 ](http://c.biancheng.net/view/1234.html)
